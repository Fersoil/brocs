# -*- coding: utf-8 -*-
"""
Created on Wed Mar 22 21:20:16 2023

Brooks theorem algorithm

@author: tymot
"""

import logging
from queue import LifoQueue, Queue
from typing import List, Optional

import networkx as nx

from brocs.algorithms import ConnectedSequential, ColoringAlgorithm
from brocs.helpers import find_common_neighbor, dist_two, dist_two_from

logger = logging.getLogger("[BROOKS]")

class BrooksAlgorithm(ColoringAlgorithm):
    """Graphs coloring algorithm based on the proof
    of the Brooks' theorem.

    Args:
        random_state: Seed for random. Makes algorithm deterministic.
    """

    random_state: Optional[int]
    cs_algorithm: ConnectedSequential

    def __init__(self, random_state: Optional[int] = None) -> None:
        super().__init__()
        self.random_state = random_state
        self.cs_algorithm = ConnectedSequential(random_state=random_state)

    def color_graph(self, G: nx.Graph) -> List[int]:
        """
        Parameters
        ----------
        G : Graph
            Graph G from nx library.

        Returns
        -------
        colors : List
            List of colors (non-negative integers), representing good coloring
            of Graph G. Coloring is generated by the algorithm adapted from Brooks theorem

        """
        # Relabed graph G to natural numbers
        nodes = G.nodes()
        mapping = dict(zip(nodes, range(len(nodes))))
        G = nx.relabel_nodes(G, mapping)
        nodes = G.nodes()

        # Define number of verticies
        number_of_nodes = len(nodes)

        # Define output array
        colors = [-1] * number_of_nodes

        # Key verticies explained in the technical documentation
        a, b, x = (None, None, None)

        # Check if graph G contains a cycle
        cycle = None
        try:
            cycle = nx.find_cycle(G, orientation="ignore")
        except nx.NetworkXNoCycle:
            logger.info("There is no cycle in graph G")

        # If graph itself is a cycle
        if cycle and len(cycle) == number_of_nodes:
            logger.info("Graph G is a cycle")
            return self.cs_algorithm.color_graph(G)

        # Find all pairs of distance two
        S = dist_two(G)
        logger.debug(S)

        # If S is empty then graph G is complete. Simple coloring
        if S == set():
            logger.info("Graph G is complete")
            return list(range(number_of_nodes))


        # Serach for optimal a and b vertexes 
        is_two_connected = True
        for pair in S:
            reduced_vertices = [i for i in range(number_of_nodes) if i not in pair]
            subG = nx.induced_subgraph(G, reduced_vertices)
            if nx.is_connected(subG):
                a, b = pair
                break

            is_two_connected = False

        # If graph is maximum 1 connected
        if not is_two_connected:
            logger.info("Graph G is maximum 1 connected")
            logger.debug("G-a-b is not connected")

            G_cut_nodes = nx.minimum_node_cut(G)
            assert isinstance(G_cut_nodes, set), "Wrong graph labels"

            if len(G_cut_nodes) == 1:
                logger.info("G is 1-connected")

                x = G_cut_nodes.pop()
                set_x_neighbors = set(G.neighbors(x))
                neighbor_colors = set()

                reduced_vertices = [i for i in range(number_of_nodes) if i != x]
                subG = nx.induced_subgraph(G, reduced_vertices)

                # miejsce do popisu to mozna zoptymalizować
                components = [c for c in nx.connected_components(subG)]

                component = components[-1]

                rest_of_graph = set(range(number_of_nodes)) - set(component)

                subG = G.subgraph(component)
                subG_size = len(component)
                sub_colors = self.cs_algorithm.color_graph(subG)
                sub_dict = dict(zip(range(subG_size), subG))

                for i in range(subG_size):
                    colors[sub_dict[i]] = sub_colors[i]

                restG = G.subgraph(rest_of_graph)
                restG_size = len(rest_of_graph)
                rest_colors = self.cs_algorithm.color_graph(restG)
                rest_dict = dict(zip(range(restG_size), restG))
                re_rest_dict = dict(zip(restG, range(restG_size)))

                for neighbor in set_x_neighbors & set(component):
                    neighbor_colors.add(colors[neighbor])

                x_color = rest_colors[re_rest_dict[x]]

                if x_color in neighbor_colors:
                    color_for_x = 0

                    while color_for_x in neighbor_colors:
                        color_for_x += 1

                    for i in range(restG_size):  # replace the colors
                        if rest_colors[i] == color_for_x:
                            rest_colors[i] = x_color
                        elif rest_colors[i] == x_color:
                            rest_colors[i] = color_for_x

                for i in range(restG_size):
                    colors[rest_dict[i]] = rest_colors[i]

                return colors
            # =============================================================================
            #             for component in components:
            #                 subG = G.subgraph(component)
            #                 subG_size = len(component)
            #                 sub_colors = connected_sequential(subG)
            #                 sub_dict = dict(zip(range(subG_size), subG))
            #                 re_sub_dict = dict(zip(subG, range(subG_size)))
            #
            #                 component_neighbors = (component & set_x_neighbors)
            #
            #
            #                 for v in component_neighbors:
            #                     neighbor_colors.add(sub_colors[re_sub_dict[v]])
            #                 else:
            #                     for i in range(subG_size): # replace the colors
            #                         if sub_colors[i] == neighbor_color:
            #                             sub_colors[i] = replace_color
            #                         elif sub_colors[i] == replace_color:
            #                             sub_colors[i] = neighbor_color
            #
            #                 for i in range(subG_size):
            #                      colors[sub_dict[i]] = sub_colors[i]
            #
            #
            #             colors[x] = replace_color
            #             return colors
            # =============================================================================

            else:
                logger.info("Graph G is 2 connected")
                t = None
                for v in nodes:
                    if 3 <= G.degree[v] < number_of_nodes - 1:
                        t = v
                        break

                # every vertex has incorrect degree
                if not t:
                    logger.info("Graph G is a extended star graph or a cycle")
                    return self.cs_algorithm.color_graph(G)

                reduced_vertices = [i for i in range(number_of_nodes) if i != t]
                subG = nx.induced_subgraph(G, reduced_vertices)
                cut_nodes = nx.minimum_node_cut(subG)

                if len(cut_nodes) >= 2:
                    a = t
                    b = dist_two_from(G, a)
                else:
                    # to moze byc zle
                    components = [c for c in nx.biconnected_components(subG)]

                    # now we look for disjoint points

                    disjoint_points = [-1] * len(components)

                    for i in range(len(components)):
                        for j in range(len(components)):
                            if i != j:
                                common_vertices = (
                                    set(components[i]) & set(components[j])
                                ).pop()
                                if common_vertices:
                                    disjoint_points[i] = common_vertices
                                    break

                    x = t
                    x_neighbors = set(G.neighbors(x))

                    # select a and b from endblocks
                    a = ((set(components[0]) - {disjoint_points[0]}) & x_neighbors).pop()
                    b = ((set(components[1]) - {disjoint_points[1]}) & x_neighbors).pop()

        # =============================================================================
        #                 reduced_vertices = [i for i in range(m) if i != x]
        #
        #                 subG = nx.induced_subgraph(G, reduced_vertices)
        #
        #                 # miejsce do popisu to mozna zoptymalizować
        #                 components = [c for c in nx.connected_components(subG)]
        #
        #                 b1 = components[0]
        #                 b2 = components[1]
        #
        #                 a = list(set(b1) & set_x_neighbors)[0]
        #                 b = list(set(b2) & set_x_neighbors)[0]
        #
        #                 print(a, b, x)
        # =============================================================================

        colors[a], colors[b] = 0, 0

        if not x:
            x = find_common_neighbor(G, a, b)

        nx.draw(G, with_labels=True)

        q = LifoQueue()
        neighbors_queue = Queue()

        is_visited = [False] * number_of_nodes

        is_visited[a], is_visited[b] = True, True
        neighbors_queue.put(x)

        # create sequence

        while not neighbors_queue.empty():
            # while there exist a vertex not in the sequence
            v = neighbors_queue.get()
            if is_visited[v]:
                continue
            q.put(v)
            for neighbor in G.neighbors(v):
                neighbors_queue.put(neighbor)

            is_visited[v] = True

        # color vertices in order given by the sequence

        while not q.empty():
            v = q.get()
            print(v)
            if colors[v] == -1:
                # if the actual vertex is uncolored
                neighbors = G.neighbors(v)
                forbidden_colors = []
                for neighbor in neighbors:
                    if colors[neighbor] != -1:
                        forbidden_colors.append(colors[neighbor])

                # now we find the smallest color that we can use
                color = 0
                while color in forbidden_colors:
                    color += 1
                colors[v] = color  # color the choosen vertex

        return colors

