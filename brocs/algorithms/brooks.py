# -*- coding: utf-8 -*-
"""
Created on Wed Mar 22 21:20:16 2023

Brooks theorem algorithm

@author: tymot
"""

import queue
import random
import networkx as nx

from cs import connected_sequential





def brooks(G):
    """
    Parameters
    ----------
    G : Graph
        Graph G from nx library.

    Returns
    -------
    colors : List
        List of colors (non-negative integers), representing good coloring 
        of Graph G. Coloring is generated by the algorithm adapted from Brooks theorem

    """

    # read graph structure
    nodes = list(G.nodes())
    m = len(nodes)

    
    colors = [-1] * m

    # check if graph is a cycle
    try:
        cycle = list(nx.find_cycle(G, orientation="ignore"))
        # there exist a cycle
        if len(cycle) == m:
            print("Graph G is a cycle")
            return connected_sequential(G) 
    except:
        print("there is no cycle in graph G")


    S = dist_two(G)
    print(S)
    
    if S == set():
        print("Graph G is complete")
        return list(range(m))

    

    for pair in S:
        reduced_vertices = [i for i in range(m) if i not in pair]
        
        subG = nx.induced_subgraph(G, reduced_vertices)
        if nx.is_connected(subG):
            a,b = pair
            break
            
    return colors




def dist_two(G):
    nodes = list(G.nodes())
    
    dist_two_set = set()
    
    for v in nodes:
        v_neighbors = list(G.neighbors(v)) # take all neighbors of v
        for v_neighbor in v_neighbors:
            for second_neighbor in G.neighbors(v_neighbor):
                if second_neighbor != v and second_neighbor not in v_neighbors:
                    dist_two_set.add((second_neighbor, v))
                    
    return dist_two_set
                
            
            
    